# grpc-osgi-generator
This project implements a protoc plugin to generate a Java service interface class and supporting classes.

For example, consider the HealthCheck service declaration in the following [health.proto](https://github.com/ECF/grpc-RemoteServicesProvider/blob/master/examples/org.eclipse.ecf.examples.provider.grpc.health.api/src/main/proto/health.proto) snippet:

```proto

service HealthCheck {
  // Unary method
  rpc Check(HealthCheckRequest) returns (HealthCheckResponse);
  // Server streaming method
  rpc Watch(HealthCheckRequest) returns (stream HealthCheckResponse);
  // Client streaming method
  rpc Watch1(stream HealthCheckRequest) returns (HealthCheckResponse);
  // bidi streaming method
  rpc Watch2(stream HealthCheckRequest) returns (stream HealthCheckResponse);
}
```
If [protoc](https://developers.google.com/protocol-buffers) is run with this proto file as input, along with the [grpc-java](https://github.com/grpc/grpc-java) and [reactive-grpc plugin](https://github.com/salesforce/reactive-grpc), along with this grpc-osgi-generator plugin, will generate the following service interface

```java
package io.grpc.health.v1;

@javax.annotation.Generated(
value = "by OSGi Remote Services generator",
comments = "Source: health.proto")
public interface HealthCheckService {

    default io.grpc.health.v1.HealthCheckResponse check(io.grpc.health.v1.HealthCheckRequest request) {
        return null;
    }
    
    /**
     * <pre>
     *  Server streaming method
     * </pre>
     */
    default io.reactivex.Flowable<io.grpc.health.v1.HealthCheckResponse> watchServer(io.reactivex.Single<io.grpc.health.v1.HealthCheckRequest> request)  {
        return null;
    }
    
    /**
     * <pre>
     *  Client streaming method
     * </pre>
     */
    default io.reactivex.Single<io.grpc.health.v1.HealthCheckResponse> watchClient(io.reactivex.Flowable<io.grpc.health.v1.HealthCheckRequest> requests)  {
        return null;
    }
    
    /**
     * <pre>
     *  bidi streaming method
     * </pre>
     */
    default io.reactivex.Flowable<io.grpc.health.v1.HealthCheckResponse> watchBidi(io.reactivex.Flowable<io.grpc.health.v1.HealthCheckRequest> requests)  {
        return null;
    }
}
```
As can be seen above, this interface class has a method corresponding to each type of [grpc](https://grpc.io/) method type:  unary, server-streaming, client-streaming, and bi-directional streaming.  The streaming methods use the Reactive Java types (Flowable and Single) in the service interface.

Note that the generated service interface uses the 'default' feature provided by Java8 or higher, and so depends upon using Java8 or higher target Java environment.

This service interface can then be used for exposing [OSGi Remote Services](https://docs.osgi.org/specification/osgi.cmpn/7.0.0/service.remoteservices.html) in [OSGi](https://www.osgi.org) environments, since all OSGi Services are based upon the service interface class.  [ECF has an implementation](https://wiki.eclipse.org/OSGi_Remote_Services_and_ECF) of a [OSGi Remote Services Distribution Provider](https://github.com/ECF/grpc-RemoteServicesProvider) that exports and imports (along with discovery) of such grpc-based services using the [OSGi Remote Service Admin](https://docs.osgi.org/specification/osgi.cmpn/7.0.0/service.remoteserviceadmin.html) specification.

The net effect of running protoc with these three protoc plugins is that the following java classes will be produced

1. Classes representing the protobuf messages and options -- via protocol buffers compiler
1. Classes providing access to grpc-based unary service methods -- via grpc-java plugin that is part of [grpc](https://github.com/grpc/)
1. Classes providing access to reactive-grpc APIs for streaming service methods (server, client, bidirectional) - via [reactive-grpc](https://github.com/salesforce/reactive-grpc)
1. A service interface class (e.g. HealthCheckService class above) that references the message types and the reactive Flowable and Single classes (see streaming HealthCheckService methods above).

[Here](https://github.com/ECF/grpc-RemoteServicesProvider/tree/master/examples/org.eclipse.ecf.examples.provider.grpc.health.api/src/main/java/io/grpc/health/v1) is the directory with the generated source code.  Note there are classes generated by protoc itself (e.g. HealthCheckRequest/HealthCheckResponse), there is a class generated by grpc (HealthCheckGrpc), there is a class generated by reactive-grpc (RxHealthCheckGrpc), and [HealthCheckService](https://github.com/ECF/grpc-RemoteServicesProvider/blob/master/examples/org.eclipse.ecf.examples.provider.grpc.health.api/src/main/java/io/grpc/health/v1/HealthCheckService.java) is generated by the plugin implemented by this project

## Using this protoc plugin via protobuf-maven-plugin

Currently the easiest way to use protoc with both the grpc-java plugin and this plugin is to use the protobuf-maven-plugin.

It's typically easiset to declare versions from within the Maven pom.xml properties section

```xml
<properties>
<!-- your other properties -->
	<rxjava.version>2.2.19</rxjava.version>
	<reactive.grpc.version>1.0.0</reactive.grpc.version>
	<grpc.contrib.version>0.8.0</grpc.contrib.version>
	<grpc.version>1.23.0</grpc.version>
</properties>
```

Then in the same pom.xml these dependencies should be present

```xml
	<dependencies>
		<dependency>
			<groupId>io.reactivex.rxjava2</groupId>
			<artifactId>rxjava</artifactId>
			<version>${rxjava.version}</version>
		</dependency>
		<dependency>
			<groupId>com.salesforce.servicelibs</groupId>
			<artifactId>rxgrpc-stub</artifactId>
			<version>${reactive.grpc.version}</version>
		</dependency>
		<dependency>
			<groupId>io.grpc</groupId>
			<artifactId>grpc-netty</artifactId>
			<version>${grpc.version}</version>
		</dependency>
		<dependency>
			<groupId>io.grpc</groupId>
			<artifactId>grpc-protobuf</artifactId>
			<version>${grpc.version}</version>
		</dependency>
		<dependency>
			<groupId>io.grpc</groupId>
			<artifactId>grpc-core</artifactId>
			<version>${grpc.version}</version>
		</dependency>
		<dependency>
			<groupId>io.grpc</groupId>
			<artifactId>grpc-context</artifactId>
			<version>${grpc.version}</version>
		</dependency>
		<dependency>
			<groupId>io.grpc</groupId>
			<artifactId>grpc-stub</artifactId>
			<version>${grpc.version}</version>
		</dependency>
	</dependencies>
```

Finally, the following extension and plugins should be in your build section (along with any other maven plugins like compile, clean, etc)

```xml
	<build>
		<extensions>
			<extension>
				<groupId>kr.motd.maven</groupId>
				<artifactId>os-maven-plugin</artifactId>
				<version>1.6.2</version>
			</extension>
		</extensions>
		<plugins>
			<plugin>
				<groupId>org.xolstice.maven.plugins</groupId>
				<artifactId>protobuf-maven-plugin</artifactId>
				<version>0.6.1</version>
				<configuration>
					<protocArtifact>com.google.protobuf:protoc:${protoc.version}:exe:${os.detected.classifier}
					</protocArtifact>
					<pluginId>grpc-java</pluginId>
					<pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}
					</pluginArtifact>
				</configuration>
				<executions>
					<execution>
						<goals>
							<goal>compile</goal>
							<goal>compile-custom</goal>
						</goals>
						<phase>generate-sources</phase>
						<configuration>
							<protocPlugins>
								<protocPlugin>
									<id>grpc-osgi-generator</id>
									<groupId>org.eclipse.ecf</groupId>
									<artifactId>grpc-osgi-generator</artifactId>
									<version>1.0.0-SNAPSHOT</version>
									<mainClass>org.eclipse.ecf.grpc.osgigenerator.OSGiGenerator
									</mainClass>
								</protocPlugin>
							</protocPlugins>
						</configuration>
					</execution>
				</executions>
			</plugin>
		</plugins>  
  </build>
```
Note in the above that the protoc + grpc-java plugin + grpc-osgi-generator will be run as part of a build (generate-sources phase) on **any .proto files in ./src/main/proto** directory and output to the **./target/generated-sources/java/** directory.  

